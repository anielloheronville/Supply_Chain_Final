# -*- coding: utf-8 -*-
"""App_Supply_Chain_Final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KNLGtmriKgB-NSBrvFjXUWRkLqo7u1oI
"""

import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import folium
from streamlit_folium import st_folium
from folium.plugins import AntPath
import numpy as np

# Configura√ß√£o da p√°gina do Streamlit
st.set_page_config(layout="wide", page_title="Dashboard de Log√≠stica e Supply Chain")

# T√≠tulo do Dashboard
st.title("üö¢ Dashboard de An√°lise Log√≠stica e Supply Chain")
st.markdown("Uma an√°lise interativa de dados simulados de log√≠stica de portos brasileiros.")

# --- 1. CARREGAMENTO E CACHE DOS DADOS ---
# A anota√ß√£o @st.cache_data garante que os dados sejam carregados apenas uma vez.
@st.cache_data
def load_data():
    try:
        df = pd.read_csv(
            'logistics_database_brazilian_ports_2M.csv',
            sep=';',
            decimal=',',
            parse_dates=['Order Date', 'Data_Prometida', 'Data_Entrega_Real'],
            encoding='utf-8-sig'
        )
        # Para garantir que as colunas de coordenadas existam para o mapa (simulando a partir do script original)
        # No seu script original, essas colunas n√£o foram salvas no CSV final.
        # Adicionaremos elas aqui para a funcionalidade do mapa.
        coordenadas_portos = {
            'Porto de Santos': (-23.988, -46.303), 'Porto de Paranagu√°': (-25.505, -48.513),
            'Porto de Itagua√≠': (-22.910, -43.818), 'Porto do Itaqui': (-2.587, -44.364),
            'Porto de Rio Grande': (-32.097, -52.122), 'Porto de Suape': (-8.397, -34.962),
            'Porto de S√£o Francisco do Sul': (-26.244, -48.643), 'Porto de Vila do Conde': (-1.551, -48.775),
            'Porto de Santar√©m': (-2.422, -54.721), 'Porto do Rio de Janeiro': (-22.896, -43.176),
            'Porto Itapo√°': (-26.115, -48.614), 'Portonave': (-26.885, -48.653),
            'Porto Chibat√£o': (-3.155, -59.972), 'Porto de Itaja√≠': (-26.908, -48.653),
            'Terminal Mar√≠tmo de Ponta da Madeira': (-2.529, -44.357), 'Terminal de Tubar√£o': (-20.285, -40.244),
            'Terminal Aquavi√°rio de Angra dos Reis': (-23.018, -44.312), 'Porto de Manaus': (-3.136, -60.021),
            'Porto de Vit√≥ria': (-20.316, -40.338), 'Porto do A√ßu': (-21.841, -41.019),
            'Terminal Portu√°rio do Pec√©m': (-3.535, -38.800), 'Porto de Salvador': (-12.962, -38.512),
            'Porto de Imbituba': (-28.232, -48.665), 'Porto de Fortaleza': (-3.714, -38.487),
            'Porto de Natal': (-5.772, -35.197)
        }
        df['Origin_Coords'] = df['Origin Port'].map(coordenadas_portos)
        df['Destination_Coords'] = df['Destination Port'].map(coordenadas_portos)
        return df, coordenadas_portos
    except FileNotFoundError:
        st.error("Erro: O arquivo 'logistics_database_brazilian_ports_2M.csv' n√£o foi encontrado.")
        st.info("Por favor, execute o notebook 'Supply_Chain_Final.ipynb' primeiro para gerar o arquivo de dados necess√°rio.")
        return None, None

df, coordenadas_portos = load_data()

# Se o DataFrame n√£o for carregado, interrompe a execu√ß√£o do restante do script.
if df is None:
    st.stop()


# --- 2. SIDEBAR DE FILTROS ---
st.sidebar.header("Filtros Interativos")

# Filtro de Data
min_date = df['Order Date'].min()
max_date = df['Order Date'].max()
date_range = st.sidebar.date_input(
    "Selecione o Per√≠odo",
    [min_date, max_date],
    min_value=min_date,
    max_value=max_date
)

# Filtro de Transportadora
all_carriers = df['Carrier'].unique()
selected_carriers = st.sidebar.multiselect(
    "Transportadora",
    options=all_carriers,
    default=all_carriers
)

# Filtro de Tipo de Carga
all_cargo_types = df['Tipo_Carga'].unique()
selected_cargo_types = st.sidebar.multiselect(
    "Tipo de Carga",
    options=all_cargo_types,
    default=all_cargo_types
)

# Aplicar filtros
start_date, end_date = pd.to_datetime(date_range)
df_filtered = df[
    (df['Order Date'] >= start_date) &
    (df['Order Date'] <= end_date) &
    (df['Carrier'].isin(selected_carriers)) &
    (df['Tipo_Carga'].isin(selected_cargo_types))
].copy()


# --- 3. KPIs PRINCIPAIS ---
st.header("KPIs de Desempenho Log√≠stico")

if df_filtered.empty:
    st.warning("Nenhum dado encontrado para os filtros selecionados.")
else:
    col1, col2, col3, col4 = st.columns(4)
    with col1:
        total_orders = df_filtered.shape[0]
        st.metric(label="Total de Pedidos", value=f"{total_orders:,}")
    with col2:
        otif_rate = df_filtered['OTIF'].mean()
        st.metric(label="Taxa OTIF M√©dia", value=f"{otif_rate:.2%}")
    with col3:
        avg_delay = df_filtered[df_filtered['Atraso_Total'] > 0]['Atraso_Total'].mean()
        st.metric(label="Atraso M√©dio (Dias)", value=f"{avg_delay:.2f}")
    with col4:
        total_cost = df_filtered['Custo_Total'].sum()
        st.metric(label="Custo Total", value=f"R$ {total_cost/1_000_000:.2f}M")


# --- 4. AN√ÅLISE GEOESPACIAL ---
st.header("An√°lise Geogr√°fica Interativa")
tab1, tab2 = st.tabs(["üó∫Ô∏è Mapa de Atividade dos Portos", "‚úàÔ∏è Mapa das Principais Rotas"])

with tab1:
    st.subheader("Volume de Pedidos por Porto (Origem + Destino)")
    mapa_portos = folium.Map(location=[-14.2350, -51.9253], zoom_start=4, tiles="CartoDB positron")

    volume_origem = df_filtered['Origin Port'].value_counts()
    volume_destino = df_filtered['Destination Port'].value_counts()
    volume_total = volume_origem.add(volume_destino, fill_value=0)

    if not volume_total.empty:
        min_volume = volume_total.min(); max_volume = volume_total.max()
        min_radius = 5; max_radius = 30

        for porto, volume in volume_total.items():
            if porto in coordenadas_portos and volume > 0:
                normalized_volume = (volume - min_volume) / (max_volume - min_volume) if (max_volume - min_volume) > 0 else 0
                radius = min_radius + (normalized_volume * (max_radius - min_radius))
                folium.CircleMarker(
                    location=coordenadas_portos[porto], radius=radius,
                    popup=f"<b>{porto}</b><br>Volume: {int(volume)} pedidos",
                    color='#007bff', fill=True, fill_color='#007bff', fill_opacity=0.6
                ).add_to(mapa_portos)
        st_folium(mapa_portos, width=1400, height=500)
    else:
        st.info("Nenhum dado de porto para exibir com os filtros atuais.")

with tab2:
    st.subheader("An√°lise das Top 25 Rotas por Volume de Pedidos")
    mapa_rotas = folium.Map(location=[-14.2350, -51.9253], zoom_start=4, tiles="CartoDB positron")

    rotas_agg = df_filtered.groupby(['Origin Port', 'Destination Port', 'Origin_Coords', 'Destination_Coords']).agg(
        Volume_Pedidos=('Order ID', 'count'), Atraso_Medio_Total=('Atraso_Total', 'mean')
    ).reset_index()

    rotas_plot = rotas_agg.nlargest(25, 'Volume_Pedidos')

    if not rotas_plot.empty:
        min_vol = rotas_plot['Volume_Pedidos'].min(); max_vol = rotas_plot['Volume_Pedidos'].max()
        min_weight = 2; max_weight = 7

        def get_route_color(atraso):
            if atraso < 0: return 'green'
            elif atraso <= 1: return 'blue'
            elif atraso <= 3: return 'orange'
            else: return 'red'

        for _, rota in rotas_plot.iterrows():
            if pd.notna(rota['Origin_Coords']) and pd.notna(rota['Destination_Coords']):
                normalized_vol = (rota['Volume_Pedidos'] - min_vol) / (max_vol - min_vol) if (max_vol - min_vol) > 0 else 0
                weight = min_weight + (normalized_vol * (max_weight - min_weight))
                AntPath(
                    locations=[rota['Origin_Coords'], rota['Destination_Coords']],
                    tooltip=(f"<b>Rota:</b> {rota['Origin Port']} ‚Üí {rota['Destination Port']}<br>"
                             f"<b>Volume:</b> {rota['Volume_Pedidos']} pedidos<br>"
                             f"<b>Atraso M√©dio:</b> {rota['Atraso_Medio_Total']:.2f} dias"),
                    delay=800, dash_array=[10, 20], weight=weight,
                    color=get_route_color(rota['Atraso_Medio_Total']), pulse_color = '#FFFFFF'
                ).add_to(mapa_rotas)
        st_folium(mapa_rotas, width=1400, height=500)
    else:
        st.info("Nenhuma rota para exibir com os filtros atuais.")

# --- 5. GR√ÅFICOS DE AN√ÅLISE ---
st.header("An√°lises de Performance, Custos e Atrasos")

col1, col2 = st.columns(2)

with col1:
    st.subheader("Desempenho OTIF por Transportadora")
    if not df_filtered.empty:
        report_carrier = df_filtered.groupby('Carrier')['OTIF'].mean().sort_values(ascending=False)
        fig, ax = plt.subplots(figsize=(10, 6))
        sns.barplot(x=report_carrier.index, y=report_carrier.values, ax=ax, palette='viridis')
        ax.set_title('Desempenho OTIF por Transportadora')
        ax.set_ylabel('Taxa OTIF')
        ax.set_xlabel('Transportadora')
        ax.set_ylim(0, 1)
        ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda y, _: f'{y:.0%}'))
        plt.xticks(rotation=45, ha='right')
        for p in ax.patches:
            ax.annotate(f'{p.get_height():.1%}', (p.get_x() + p.get_width() / 2., p.get_height()),
                        ha='center', va='center', xytext=(0, 9), textcoords='offset points')
        st.pyplot(fig)
    else:
        st.info("Nenhum dado para o gr√°fico de OTIF por Transportadora.")


with col2:
    st.subheader("Top 10 Rotas por Custo Total")
    if not df_filtered.empty:
        report_costs = df_filtered.groupby(['Origin Port', 'Destination Port']).agg(Custo_Total=('Custo_Total', 'sum')).nlargest(10, 'Custo_Total')
        report_costs = report_costs.reset_index()
        report_costs['Rota'] = report_costs['Origin Port'] + ' ‚Üí ' + report_costs['Destination Port']

        fig, ax = plt.subplots(figsize=(10, 6))
        sns.barplot(x='Custo_Total', y='Rota', data=report_costs, ax=ax, palette='rocket')
        ax.set_title('Top 10 Rotas por Custo Total')
        ax.set_xlabel('Custo Total (R$)')
        ax.set_ylabel('Rota')
        for p in ax.patches:
            ax.text(p.get_width(), p.get_y() + p.get_height() / 2, f' R${p.get_width()/1_000_000:.2f}M', va='center')
        st.pyplot(fig)
    else:
        st.info("Nenhum dado para o gr√°fico de Top 10 Rotas por Custo.")

col3, col4 = st.columns(2)

with col3:
    st.subheader("Performance OTIF por Tipo de Carga")
    if not df_filtered.empty:
        otif_por_carga = df_filtered.groupby('Tipo_Carga')['OTIF'].mean().sort_values(ascending=False)
        fig, ax = plt.subplots(figsize=(10, 6))
        otif_por_carga.plot(kind='bar', ax=ax, title='Performance OTIF por Tipo de Carga', color=['#3b5998', '#ff9900', '#8b4513'])
        plt.ylabel('Taxa OTIF')
        plt.xlabel('Tipo de Carga')
        plt.xticks(rotation=0)
        ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda y, _: '{:.0%}'.format(y)))
        ax.set_ylim(0, 1)
        st.pyplot(fig)
    else:
        st.info("Nenhum dado para o gr√°fico de OTIF por tipo de carga.")

with col4:
    st.subheader("An√°lise de Motivos de Atraso")
    # Para este gr√°fico, precisamos da coluna 'Motivo_Atraso' que n√£o est√° no CSV final.
    # Vamos gerar dados simulados para demonstra√ß√£o.
    if not df_filtered.empty and 'Atraso_Total' in df_filtered.columns:
        df_atrasados = df_filtered[df_filtered['Atraso_Total'] > 0]
        if not df_atrasados.empty:
            motivos = [
                'Congestionamento no Porto', 'Atraso na Alf√¢ndega', 'Problema Operacional',
                'Condi√ß√µes Clim√°ticas', 'Falha de Equipamento', 'Inspe√ß√£o da Carga', 'Greves'
            ]
            probabilidades_motivos = [0.25, 0.20, 0.15, 0.15, 0.10, 0.10, 0.05]
            # Adicionando a coluna 'Motivo_Atraso' se n√£o existir
            if 'Motivo_Atraso' not in df_atrasados.columns:
                df_atrasados['Motivo_Atraso'] = np.random.choice(motivos, size=len(df_atrasados), p=probabilidades_motivos)

            report_delays = df_atrasados['Motivo_Atraso'].value_counts().reset_index()
            report_delays.columns = ['Motivo_Atraso', 'Numero_Ocorrencias']

            fig, ax = plt.subplots(figsize=(10, 6))
            sns.barplot(x='Numero_Ocorrencias', y='Motivo_Atraso', data=report_delays, ax=ax, palette='mako')
            ax.set_title('Principais Motivos de Atraso')
            ax.set_xlabel('N√∫mero de Ocorr√™ncias')
            ax.set_ylabel('Motivo do Atraso')
            st.pyplot(fig)
        else:
            st.info("Nenhum atraso registrado para os filtros selecionados.")
    else:
        st.info("Dados de atraso n√£o dispon√≠veis.")


# --- 6. AN√ÅLISE DE TEND√äNCIAS E CORRELA√á√ÉO ---
st.header("An√°lise de Tend√™ncias e Correla√ß√µes")
tab3, tab4 = st.tabs(["üìà Tend√™ncia Mensal da Taxa OTIF", "üîó Mapa de Calor de Correla√ß√£o"])

with tab3:
    if not df_filtered.empty:
        report_trends = df_filtered.set_index('Order Date').groupby(pd.Grouper(freq='M')).agg(OTIF_Rate=('OTIF', 'mean'))
        fig, ax = plt.subplots(figsize=(15, 7))
        report_trends['OTIF_Rate'].plot(kind='line', marker='o', linestyle='-', ax=ax)
        plt.title('Tend√™ncia Mensal da Taxa OTIF', fontsize=16)
        plt.ylabel('Taxa OTIF', fontsize=12)
        plt.xlabel('M√™s', fontsize=12)
        plt.grid(True, which='both', linestyle='--', linewidth=0.5)
        ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda y, _: f'{y:.0%}'))
        ax.set_ylim(0, max(0.1, report_trends['OTIF_Rate'].max() * 1.2))
        st.pyplot(fig)
    else:
        st.info("Nenhum dado para exibir o gr√°fico de tend√™ncias.")

with tab4:
    if not df_filtered.empty:
        correlation_matrix = df_filtered[['Unit quantity', 'Weight', 'Custo_Total', 'Atraso_Total', 'Satisfacao_Cliente']].corr()
        fig, ax = plt.subplots(figsize=(10, 7))
        sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f", ax=ax)
        plt.title('Mapa de Calor de Correla√ß√£o')
        st.pyplot(fig)
    else:
        st.info("Nenhum dado para exibir o mapa de calor.")


# --- 7. EXPLORA√á√ÉO DOS DADOS ---
st.header("Explora√ß√£o dos Dados Brutos")
st.dataframe(df_filtered.head(100))